{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Whole Body Toolbox A Simulink Toolbox for Whole Body Control This toolbox allows non-programming experts and researchers approaching Whole Body Control to more easily develop controllers on either simulated or real YARP -based robotic platforms. Develop to deployment time is minimized by exploiting the rich variety of Simulink's toolboxes and its capabilities on rapid prototyping and visual debugging. Who use WB-Toolbox WB-Toolbox is used extensively in the controllers stored in robotology-playground/whole-body-controllers . This video shows the latest results on the iCub robot achieved in the EU project CoDyCo in which a top level controller implemented with the robotology/WB-Toolbox achieves a running 100 Hz rate. Citing this work Romano F., Traversaro S., Pucci D., Nori F. A Whole-Body Software Abstraction layer for Control Design of free-floating Mechanical Systems Journal of Software Engineering for Robotics, 2017 Bibtex citation @ARTICLE{RomanoWBI17Journal, author={F. Romano and S. Traversaro and D. Pucci and F. Nori}, journal={Journal of Software Engineering for Robotics}, title={A Whole-Body Software Abstraction layer for Control Design of free-floating Mechanical Systems}, year={2017}, }","title":"Home"},{"location":"#whole-body-toolbox","text":"","title":"Whole Body Toolbox"},{"location":"#a-simulink-toolbox-for-whole-body-control","text":"This toolbox allows non-programming experts and researchers approaching Whole Body Control to more easily develop controllers on either simulated or real YARP -based robotic platforms. Develop to deployment time is minimized by exploiting the rich variety of Simulink's toolboxes and its capabilities on rapid prototyping and visual debugging.","title":"A Simulink Toolbox for Whole Body Control"},{"location":"#who-use-wb-toolbox","text":"WB-Toolbox is used extensively in the controllers stored in robotology-playground/whole-body-controllers . This video shows the latest results on the iCub robot achieved in the EU project CoDyCo in which a top level controller implemented with the robotology/WB-Toolbox achieves a running 100 Hz rate.","title":"Who use WB-Toolbox"},{"location":"#citing-this-work","text":"Romano F., Traversaro S., Pucci D., Nori F. A Whole-Body Software Abstraction layer for Control Design of free-floating Mechanical Systems Journal of Software Engineering for Robotics, 2017 Bibtex citation @ARTICLE{RomanoWBI17Journal, author={F. Romano and S. Traversaro and D. Pucci and F. Nori}, journal={Journal of Software Engineering for Robotics}, title={A Whole-Body Software Abstraction layer for Control Design of free-floating Mechanical Systems}, year={2017}, }","title":"Citing this work"},{"location":"Migration_from_WB-Toolbox_2.0/","text":"From WB-Toolbox 2.0 to WB-Toolbox 3.* Most of the major changes delivered with the 3.0 version of the WB-Toolbox don't affect directly the end-user. Under the hood the toolbox had an important polishing, and the small manual intervention required by this new release match the new features which have been developed. You can read Release Notes for a detailed overview. Below are described only the steps required to port Simulink models to this new release. New toolbox configuration The WB-Toolbox 2.0 was based on top of yarpWholeBodyInterface , which configuration was stored in a yarpWholeBodyInterface.ini file. This file was retrieved by ResourceFinder and its information was then loaded into the toolbox. Store the configuration in the Simulink model WB-Toolbox 3.0 deprecated the support of yarpWholeBodyInterface , and for reducing the complexity and sparsity of the information storage it allows configuring a Simulink model from the model itself. The new Configuration block allows inserting information such as Robot Name , URDF Name , Controlled Joints , ... directly from the block's mask. Load the configuration from the Workspace Sometimes it might be useful loading the model's configuration directly from the Workspace. For this purpose, a new WBToolbox.WBToolboxConfig class has been developed. The Configuration block needs to know only the name of the variable which refers to the object. Its data is then read before the simulation runs. This snippet of code shows an example of how to initialize a configuration object: # Initialize a config object WBTConfigRobot = WBToolbox . WBToolboxConfig ; # Insert robot data WBTConfigRobot . RobotName = icubSim ; WBTConfigRobot . UrdfFile = model.urdf ; WBTConfigRobot . ControlledJoints = { ... torso_pitch , torso_roll , torso_yaw , ... r_shoulder_pitch , r_shoulder_roll , r_shoulder_yaw , r_elbow , ... l_shoulder_pitch , l_shoulder_roll , l_shoulder_yaw , l_elbow }; WBTConfigRobot . ControlBoardsNames = { torso , left_arm , right_arm }; WBTConfigRobot . LocalName = WBT ; To check if the data has been read correctly, it is displayed as read-only in the block's mask. Furthermore, a good sign for a valid configuration is the WBTConfigRobot.ValidConfiguration property. Multi-robot support The scope of the introduction of the Configuration block goes beyond the need of a simpler toolbox configuration. One of the biggest limitation of the 2.0 version is the support of controlling only one robot per model . WB-Toolbox 3.0 is now capable of reading / sending data from / to multiple robots. Multiple Configuration blocks can be present in the same model attaining to the following rules: In the same hierarchical level of a Simulink model, only one Configuration block should be present. In other words, you should never see in the display more than one Configuration block. Configuration blocks put deeper in the hierarchy (e.g. in a Subsystem) override the previous ones. There are a few pitfalls which are worth to be highlighted: It is legit having two Subsystems with different Configuration blocks which point to the same robot. They can have for instance a different joint list and use different control boards. Although, despite reading information never creates problems, sending data to the robot in such scenario can be disastrous. In fact, consider the case these two subsystems share one link, and configure it in two different control modes (e.g. Position and Torque). Sending references to this link causes unpredictable effects. In line of theory it would be possible to have two subsystems in which the first one refers to a Gazebo model and the second one to a real robot. However, this case causes unpredictable behaviour for what concerns the synchronization. In fact, two different blocks for such aim are present in the toolbox: Simulator Synchronizer and Real Time Syncronizer . They should be always used exclusively. Other manual edits All the Get Estimate blocks need to be replaced by the new Get Measurement block. All the hardcoded digital filters (e.g. for the joints velocities) have been removed. A new Discrete Filter block has been developed, and it should be manually added if the read raw signal (e.g. from the Get Measurement block) requires filtering. The C++ class used by the DoFs Converter changed. All the blocks in the YARP To WBI configuration need to be connected again. The gravity vector is stored is the WBToolboxConfig class. If an alternative value is needed, set it globally directly in the configuration object or scope the block which needs it in a Subsystem with its own Configuration block. In order to set the low level PIDs, loading in the Workspace a WBToolbox.WBTPIDConfig object should be configured as follows: # Initialize an empty object pids = WBToolbox . WBTPIDConfig ; # Insert data pids . addPID ( WBToolbox . PID ( l_elbow , WBToolbox . PID ( 1 , 1 , 0 ))); pids . addPID ( WBToolbox . PID ( l_wrist_pitch , WBToolbox . PID ( 1.5 , 0 , 0.1 ))); pids . addPID ( WBToolbox . PID ( r_shoulder_pitch , WBToolbox . PID ( 0.2 , 0 , 0 ))); pids . addPID ( WBToolbox . PID ( torso_roll , WBToolbox . PID ( 0.1 , 0.1 , 0 ))); If some of the controlled joints are not specified, the PIDs are kept in their default values. Deprecations Inverse Kinematics and Remote Inverse Kinematics have been temporary deprecated. They will see a major release in the coming months. If you need them please do not upgrade to the 3.0 version. Set Low Level PID block lost the capability of switching between multiple configurations. Since they were stored in an external file, this change is aligned to the simplification process chosen for for the configuration.","title":"From WB-Toolbox 2.0"},{"location":"Migration_from_WB-Toolbox_2.0/#from-wb-toolbox-20-to-wb-toolbox-3","text":"Most of the major changes delivered with the 3.0 version of the WB-Toolbox don't affect directly the end-user. Under the hood the toolbox had an important polishing, and the small manual intervention required by this new release match the new features which have been developed. You can read Release Notes for a detailed overview. Below are described only the steps required to port Simulink models to this new release.","title":"From WB-Toolbox 2.0 to WB-Toolbox 3.*"},{"location":"Migration_from_WB-Toolbox_2.0/#new-toolbox-configuration","text":"The WB-Toolbox 2.0 was based on top of yarpWholeBodyInterface , which configuration was stored in a yarpWholeBodyInterface.ini file. This file was retrieved by ResourceFinder and its information was then loaded into the toolbox.","title":"New toolbox configuration"},{"location":"Migration_from_WB-Toolbox_2.0/#store-the-configuration-in-the-simulink-model","text":"WB-Toolbox 3.0 deprecated the support of yarpWholeBodyInterface , and for reducing the complexity and sparsity of the information storage it allows configuring a Simulink model from the model itself. The new Configuration block allows inserting information such as Robot Name , URDF Name , Controlled Joints , ... directly from the block's mask.","title":"Store the configuration in the Simulink model"},{"location":"Migration_from_WB-Toolbox_2.0/#load-the-configuration-from-the-workspace","text":"Sometimes it might be useful loading the model's configuration directly from the Workspace. For this purpose, a new WBToolbox.WBToolboxConfig class has been developed. The Configuration block needs to know only the name of the variable which refers to the object. Its data is then read before the simulation runs. This snippet of code shows an example of how to initialize a configuration object: # Initialize a config object WBTConfigRobot = WBToolbox . WBToolboxConfig ; # Insert robot data WBTConfigRobot . RobotName = icubSim ; WBTConfigRobot . UrdfFile = model.urdf ; WBTConfigRobot . ControlledJoints = { ... torso_pitch , torso_roll , torso_yaw , ... r_shoulder_pitch , r_shoulder_roll , r_shoulder_yaw , r_elbow , ... l_shoulder_pitch , l_shoulder_roll , l_shoulder_yaw , l_elbow }; WBTConfigRobot . ControlBoardsNames = { torso , left_arm , right_arm }; WBTConfigRobot . LocalName = WBT ; To check if the data has been read correctly, it is displayed as read-only in the block's mask. Furthermore, a good sign for a valid configuration is the WBTConfigRobot.ValidConfiguration property.","title":"Load the configuration from the Workspace"},{"location":"Migration_from_WB-Toolbox_2.0/#multi-robot-support","text":"The scope of the introduction of the Configuration block goes beyond the need of a simpler toolbox configuration. One of the biggest limitation of the 2.0 version is the support of controlling only one robot per model . WB-Toolbox 3.0 is now capable of reading / sending data from / to multiple robots. Multiple Configuration blocks can be present in the same model attaining to the following rules: In the same hierarchical level of a Simulink model, only one Configuration block should be present. In other words, you should never see in the display more than one Configuration block. Configuration blocks put deeper in the hierarchy (e.g. in a Subsystem) override the previous ones. There are a few pitfalls which are worth to be highlighted: It is legit having two Subsystems with different Configuration blocks which point to the same robot. They can have for instance a different joint list and use different control boards. Although, despite reading information never creates problems, sending data to the robot in such scenario can be disastrous. In fact, consider the case these two subsystems share one link, and configure it in two different control modes (e.g. Position and Torque). Sending references to this link causes unpredictable effects. In line of theory it would be possible to have two subsystems in which the first one refers to a Gazebo model and the second one to a real robot. However, this case causes unpredictable behaviour for what concerns the synchronization. In fact, two different blocks for such aim are present in the toolbox: Simulator Synchronizer and Real Time Syncronizer . They should be always used exclusively.","title":"Multi-robot support"},{"location":"Migration_from_WB-Toolbox_2.0/#other-manual-edits","text":"All the Get Estimate blocks need to be replaced by the new Get Measurement block. All the hardcoded digital filters (e.g. for the joints velocities) have been removed. A new Discrete Filter block has been developed, and it should be manually added if the read raw signal (e.g. from the Get Measurement block) requires filtering. The C++ class used by the DoFs Converter changed. All the blocks in the YARP To WBI configuration need to be connected again. The gravity vector is stored is the WBToolboxConfig class. If an alternative value is needed, set it globally directly in the configuration object or scope the block which needs it in a Subsystem with its own Configuration block. In order to set the low level PIDs, loading in the Workspace a WBToolbox.WBTPIDConfig object should be configured as follows: # Initialize an empty object pids = WBToolbox . WBTPIDConfig ; # Insert data pids . addPID ( WBToolbox . PID ( l_elbow , WBToolbox . PID ( 1 , 1 , 0 ))); pids . addPID ( WBToolbox . PID ( l_wrist_pitch , WBToolbox . PID ( 1.5 , 0 , 0.1 ))); pids . addPID ( WBToolbox . PID ( r_shoulder_pitch , WBToolbox . PID ( 0.2 , 0 , 0 ))); pids . addPID ( WBToolbox . PID ( torso_roll , WBToolbox . PID ( 0.1 , 0.1 , 0 ))); If some of the controlled joints are not specified, the PIDs are kept in their default values.","title":"Other manual edits"},{"location":"Migration_from_WB-Toolbox_2.0/#deprecations","text":"Inverse Kinematics and Remote Inverse Kinematics have been temporary deprecated. They will see a major release in the coming months. If you need them please do not upgrade to the 3.0 version. Set Low Level PID block lost the capability of switching between multiple configurations. Since they were stored in an external file, this change is aligned to the simplification process chosen for for the configuration.","title":"Deprecations"},{"location":"Migration_from_WBI-Toolbox_1.0/","text":"From WBI-Toolbox to WB-Toolbox 2.* Given a simulink model with some WBI-Toolbox blocks inside, the general procedure is to substitute each block with the corresponding one from WB-Toolbox 2.0 . However, there are some things the user should take care while doing this operation. This guide points out the main differences between the two toolboxes. For more information about the WBI-Toolbox, please have a look at the WBI-Toolbox README . This guide follows the WBI and WB Toolbox blocks partitioning in Simulink library. It is divided in the following sections: Required variables Utilities wholeBodyActuators wholeBodyModel wholeBodyStates Required variables As explained in the WB-Toolbox README , first of all the user should define the following variables: - WBT_modelName - WBT_wbiList - WBT_wbiFilename - WBT_robotName They have already meaningful default values. Nevertheless you should take a look at at least the following two variables: - WBT_modelname = 'matlabTorqueBalancing' or be careful that the default name does not conflicts with any other modules or YARP ports - WBT_wbiList = 'ROBOT_TORQUE_CONTROL_JOINTS_WITHOUT_PRONOSUP' if you simulate a 23-DoFs iCub robot Floating base position estimate In the WB-Toolbox the world-to-base homogeneous transformation matrix is not calculated inside each block, but it must be provided from the Simulink model as a block input. The world-to-base homogeneous transformation matrix is a 4x4 matrix that maps position and orientation of a rigid body from an initial frame of reference to another. For back-compatibility, the transformation happending under the hood in the WBI-Toolbox can be obtained using forward kinematics blocks as in the following example: where forward kinematics is used to compute the transformation matrices from world to the left foot and from world to the root link, while the desired transformation matrix is obtained as a matrices product, using the homogeneous transformation matrix properties. Utilities In this section the user should note that: - the Minimum Jerk Trajectory Generator block has now only the reference trajectory as input. The initial value is automatically taken at startup. - Yarp Read and some other blocks require now the WBT_modelName instead of the localName variable. wholeBodyActuators Instead of having different blocks for each kind of control mode, only one block is now present. The user can choose the control mode by double-clicking on it and selecting one of the possible modes (position, position direct, velocity and torques) wholeBodyModel It is divided into three subsections. The Joint Limits block is now moved into wholeBodyStates section. Dynamics the dJdq blocks have been moved into jacobians subsection; for mass matrix, generalized bias forces and centroidal momentum computation is now required to calculate explicitly the world-to-base homogeneous transformation matrix and the base velocity. Furthermore, the base frame pose and velocity and the joint configuration are now separate inputs. Jacobians There is now only one generic block for jacobians and one for dJdq calculation. The link with respect to which the Jacobian is computed is determined by its frame name as specified in the URDF model . As for the dynamics, the base pose and velocity and the joint position and velocity are required as input. Kinematics As for the section Jacobians , there is now only one generic block for forward kinematics computation. World-to-base homogeneous transformation matrix and joint position are the required input. wholeBodyStates As in the previous section, one generic block is used, from which the user can estimate joint position, velocity and acceleration and joint torques. The Joint Limits block is moved into this section.","title":"From WBI-Toolbox"},{"location":"Migration_from_WBI-Toolbox_1.0/#from-wbi-toolbox-to-wb-toolbox-2","text":"Given a simulink model with some WBI-Toolbox blocks inside, the general procedure is to substitute each block with the corresponding one from WB-Toolbox 2.0 . However, there are some things the user should take care while doing this operation. This guide points out the main differences between the two toolboxes. For more information about the WBI-Toolbox, please have a look at the WBI-Toolbox README . This guide follows the WBI and WB Toolbox blocks partitioning in Simulink library. It is divided in the following sections: Required variables Utilities wholeBodyActuators wholeBodyModel wholeBodyStates","title":"From WBI-Toolbox to WB-Toolbox 2.*"},{"location":"Migration_from_WBI-Toolbox_1.0/#required-variables","text":"As explained in the WB-Toolbox README , first of all the user should define the following variables: - WBT_modelName - WBT_wbiList - WBT_wbiFilename - WBT_robotName They have already meaningful default values. Nevertheless you should take a look at at least the following two variables: - WBT_modelname = 'matlabTorqueBalancing' or be careful that the default name does not conflicts with any other modules or YARP ports - WBT_wbiList = 'ROBOT_TORQUE_CONTROL_JOINTS_WITHOUT_PRONOSUP' if you simulate a 23-DoFs iCub robot","title":"Required variables"},{"location":"Migration_from_WBI-Toolbox_1.0/#floating-base-position-estimate","text":"In the WB-Toolbox the world-to-base homogeneous transformation matrix is not calculated inside each block, but it must be provided from the Simulink model as a block input. The world-to-base homogeneous transformation matrix is a 4x4 matrix that maps position and orientation of a rigid body from an initial frame of reference to another. For back-compatibility, the transformation happending under the hood in the WBI-Toolbox can be obtained using forward kinematics blocks as in the following example: where forward kinematics is used to compute the transformation matrices from world to the left foot and from world to the root link, while the desired transformation matrix is obtained as a matrices product, using the homogeneous transformation matrix properties.","title":"Floating base position estimate"},{"location":"Migration_from_WBI-Toolbox_1.0/#utilities","text":"In this section the user should note that: - the Minimum Jerk Trajectory Generator block has now only the reference trajectory as input. The initial value is automatically taken at startup. - Yarp Read and some other blocks require now the WBT_modelName instead of the localName variable.","title":"Utilities"},{"location":"Migration_from_WBI-Toolbox_1.0/#wholebodyactuators","text":"Instead of having different blocks for each kind of control mode, only one block is now present. The user can choose the control mode by double-clicking on it and selecting one of the possible modes (position, position direct, velocity and torques)","title":"wholeBodyActuators"},{"location":"Migration_from_WBI-Toolbox_1.0/#wholebodymodel","text":"It is divided into three subsections. The Joint Limits block is now moved into wholeBodyStates section.","title":"wholeBodyModel"},{"location":"Migration_from_WBI-Toolbox_1.0/#dynamics","text":"the dJdq blocks have been moved into jacobians subsection; for mass matrix, generalized bias forces and centroidal momentum computation is now required to calculate explicitly the world-to-base homogeneous transformation matrix and the base velocity. Furthermore, the base frame pose and velocity and the joint configuration are now separate inputs.","title":"Dynamics"},{"location":"Migration_from_WBI-Toolbox_1.0/#jacobians","text":"There is now only one generic block for jacobians and one for dJdq calculation. The link with respect to which the Jacobian is computed is determined by its frame name as specified in the URDF model . As for the dynamics, the base pose and velocity and the joint position and velocity are required as input.","title":"Jacobians"},{"location":"Migration_from_WBI-Toolbox_1.0/#kinematics","text":"As for the section Jacobians , there is now only one generic block for forward kinematics computation. World-to-base homogeneous transformation matrix and joint position are the required input.","title":"Kinematics"},{"location":"Migration_from_WBI-Toolbox_1.0/#wholebodystates","text":"As in the previous section, one generic block is used, from which the user can estimate joint position, velocity and acceleration and joint torques. The Joint Limits block is moved into this section.","title":"wholeBodyStates"},{"location":"about/","text":"WB-Toolbox has been developed in the Dynamic Interaction Control research line at the Italian Institute of Technology . It was born from the ashes of robotology-playground/WBI-Toolbox . It is used extensively for controllers stored in robotology-playground/whole-body-controllers . Maintainer Ferigo Diego ( @diegoferigo ) Contributors In alphabetical order: Eljaik Jorhabib ( @jeljaik ) Ferigo Diego ( @diegoferigo ) Nori Francesco ( @iron76 ) Pucci Daniele ( @DanielePucci ) Romano Francesco ( @francesco-romano ) Traversaro Silvio ( @traversaro ) Acknowledgments The development of WB-Toolbox is supported by: FP7 EU projects CoDyCo (No. 600716 ICT 2011.2.1 Cognitive Systems and Robotics) H2020 EU projects AnDy (No. 731540 H2020-ICT-2016-1)","title":"About"},{"location":"about/#maintainer","text":"Ferigo Diego ( @diegoferigo )","title":"Maintainer"},{"location":"about/#contributors","text":"In alphabetical order: Eljaik Jorhabib ( @jeljaik ) Ferigo Diego ( @diegoferigo ) Nori Francesco ( @iron76 ) Pucci Daniele ( @DanielePucci ) Romano Francesco ( @francesco-romano ) Traversaro Silvio ( @traversaro )","title":"Contributors"},{"location":"about/#acknowledgments","text":"The development of WB-Toolbox is supported by: FP7 EU projects CoDyCo (No. 600716 ICT 2011.2.1 Cognitive Systems and Robotics) H2020 EU projects AnDy (No. 731540 H2020-ICT-2016-1)","title":"Acknowledgments"},{"location":"create_new_block/","text":"Warning These information are outdated. The need to be ported to WB-Toolbox 3 . The following steps are necessary in order to add additional blocks to the Library. C++ Generic Block Inherit from Block class Implement the numberOfParameters() function returning the number of parameters your block takes If the parameter is tunable (i.e. it can be changed during the simulation) implement parameterAtIndexIsTunable : by default parameters are not tunable Implement the configureSizeAndPorts method to properly set the number and type of input and output ports Implement the initialize method to perform any initialization your block requires Implement the finilize method to cleanup any resources your block requested in the initialize method Implement the output method to perform the actual operations You can access the block parameters by using the usual mex C functions. NOTE your parameters are 1-based numbered, NOT 0-based. So the first parameter is at index 1, etc... WBI-based Block If you need to implement a WBI-based block it is highly advisable that you inherit from WBIBlock class. This base class already implements a lot of functionalities and it is highly probable you need to just implement the output function. The WBIBlock base class already provide you the following features: The number of parameters is already set to 4 ( robot name , model name , wbi filename , wbi joint list ) and they are correctly parsed. An instance of the Yarp WholeBody interface is configured, initialized, and properly released in the finilize method. The Yarp network properly initialized and terminated. You can obtain a reference to the singleton WB Interface wrapper by calling the static method WBInterface::sharedInstance . Note Additional parameters you specify starts from the index 5 . Notes on implementation During configureSizeAndPorts you should not allocate any memory or save any data because the object will not persist after the method call. The correct place is the initialize method. Every function takes as last parameter an Error object. It can be NULL , so check before dereferencing the pointer. Final steps Independently of the type of block you implemented some more steps are required to properly add the block. CMake You can use the macro provided by this project: configure_block ( BLOCK_NAME ${ HUMAN_READABLE_DESCRIPTION } LIST_PREFIX WBT SOURCES ${ CPP_FILES } HEADERS ${ HEADER_FILES } ) where ${HUMAN_READABLE_DESCRIPTION} is a string used in the group folder (for projects which support it), ${CPP_FILES} is a list of .cpp files needed by your block ${HEADER_FILES} is a list of .h files needed by your block Block Factory Add you main header to the toolbox.h file Add the code needed for the creation of your class in factory.cpp , Block::instantiateBlockWithClassName method. The string passed as argument is the one you specify in the S-Function block in Simulink (see next section) Simulink Add an S-Function block Specify as s-function name WB-Toolbox Add the parameters: The first parameter is the name of the class, e.g. YarpRead If you are creating a WBI-based block you have to specify 4 additional parameters: robot name , model name , YarpWBI configuration file , YarpWBI Joint list Add any additional parameter required by your block Create a Subsystem and add a Mask to it Note you should use variables for the S-Function parameters and you should specify them in the mask parameters. Note you can also supply default values for the variables by adding code in the Block- Properties- Callbacks- Init You can skip most of the aforementioned steps by duplicating an already existing block. Just be sure you are duplicating it and not creating an alias.","title":"Add a new block"},{"location":"create_new_block/#c","text":"","title":"C++"},{"location":"create_new_block/#generic-block","text":"Inherit from Block class Implement the numberOfParameters() function returning the number of parameters your block takes If the parameter is tunable (i.e. it can be changed during the simulation) implement parameterAtIndexIsTunable : by default parameters are not tunable Implement the configureSizeAndPorts method to properly set the number and type of input and output ports Implement the initialize method to perform any initialization your block requires Implement the finilize method to cleanup any resources your block requested in the initialize method Implement the output method to perform the actual operations You can access the block parameters by using the usual mex C functions. NOTE your parameters are 1-based numbered, NOT 0-based. So the first parameter is at index 1, etc...","title":"Generic Block"},{"location":"create_new_block/#wbi-based-block","text":"If you need to implement a WBI-based block it is highly advisable that you inherit from WBIBlock class. This base class already implements a lot of functionalities and it is highly probable you need to just implement the output function. The WBIBlock base class already provide you the following features: The number of parameters is already set to 4 ( robot name , model name , wbi filename , wbi joint list ) and they are correctly parsed. An instance of the Yarp WholeBody interface is configured, initialized, and properly released in the finilize method. The Yarp network properly initialized and terminated. You can obtain a reference to the singleton WB Interface wrapper by calling the static method WBInterface::sharedInstance . Note Additional parameters you specify starts from the index 5 .","title":"WBI-based Block"},{"location":"create_new_block/#notes-on-implementation","text":"During configureSizeAndPorts you should not allocate any memory or save any data because the object will not persist after the method call. The correct place is the initialize method. Every function takes as last parameter an Error object. It can be NULL , so check before dereferencing the pointer.","title":"Notes on implementation"},{"location":"create_new_block/#final-steps","text":"Independently of the type of block you implemented some more steps are required to properly add the block.","title":"Final steps"},{"location":"create_new_block/#cmake","text":"You can use the macro provided by this project: configure_block ( BLOCK_NAME ${ HUMAN_READABLE_DESCRIPTION } LIST_PREFIX WBT SOURCES ${ CPP_FILES } HEADERS ${ HEADER_FILES } ) where ${HUMAN_READABLE_DESCRIPTION} is a string used in the group folder (for projects which support it), ${CPP_FILES} is a list of .cpp files needed by your block ${HEADER_FILES} is a list of .h files needed by your block","title":"CMake"},{"location":"create_new_block/#block-factory","text":"Add you main header to the toolbox.h file Add the code needed for the creation of your class in factory.cpp , Block::instantiateBlockWithClassName method. The string passed as argument is the one you specify in the S-Function block in Simulink (see next section)","title":"Block Factory"},{"location":"create_new_block/#simulink","text":"Add an S-Function block Specify as s-function name WB-Toolbox Add the parameters: The first parameter is the name of the class, e.g. YarpRead If you are creating a WBI-based block you have to specify 4 additional parameters: robot name , model name , YarpWBI configuration file , YarpWBI Joint list Add any additional parameter required by your block Create a Subsystem and add a Mask to it Note you should use variables for the S-Function parameters and you should specify them in the mask parameters. Note you can also supply default values for the variables by adding code in the Block- Properties- Callbacks- Init You can skip most of the aforementioned steps by duplicating an already existing block. Just be sure you are duplicating it and not creating an alias.","title":"Simulink"},{"location":"create_new_library/","text":"Tutorial: How to create a new library This guide describes how to use the core infrastructure of the Whole Body Toolbox for creating a new toolbox Toolbox Example . It will contain a single block Signal math with the following specifications: Accepts two input signals Performs element-wise operations: sum, subtraction, multiplication Allows to select the operation with a user friendly GUI (mask) Produces an output signal with the result of the operation Despite it is a very trivial example, it shows how to structure both the C++ and the Matlab components of a toolbox. From this starting point is then possible to build more complex architectures which might need e.g. to be split in many parts or to link against third-party libraries. Toolbox Example project You can find the files of this example in the example folder. Info Until v4 this core machinery is shipped together with our robotics framework. We're currently working on splitting the toolbox components for providing a standalone process. Stay tuned for upcoming news! Introduction Before jumping in the example of this tutorial, in this section you will find helpful information useful to grasp the key ideas about the toolbox and a refreshing of common terms and patterns used in programming. Algorithm specifications The execution of a generic algorithm can be split in the following basic phases: Configuration Initialization Step Termination In the configuration phase the algorithm can, for instance, read parameters and specify details about its inputs and outputs. During the initialization it might need to allocate resources. When everything is ready, the simulation starts and on every cycle of the loop the algorithm computes a step. Before finishing the simulation, in the termination step the resources that are not anymore needed can be deallocated and final operations can be executed. Terminology There are few key components which are part of the core infrastructure, and it is important they are clear from the very beginning. Note This project has strong roots with Simulink. Despite it is not anymore strictly related to it, the structure keeps as inheritance its terminology. Block The Block is the main component of the toolbox. You may think of it as a wrapper for a generic algorithm. It provides support of all the phases discussed above. Port Blocks need to interface with the outside for reading input data and writing their results. Ports are attached to the Block and let data flow in and out from it. They have properties like the accepted data type and they are characterized by a size. Signal A Signal is the generalization of a buffer. It can be plugged to multiple Ports and allows sharing data between them. Similarly to Ports, a Signal has a data type and a width. When a Signal is connected to a Port, their dimension must match. Engine The engine is the framework that calls and executes the code implementing the Blocks. We currently provide support for Simulink and Simulink Coder. Alternative engines might be Scilab or even standalone C++ code. BlockInformation BlockInformation is the interface between a Block and the engine that executes its code. Despite blocks are not aware of what engine is executing them, blocks and engine need to exchange information such as user parameters and Port data. BlockInformation provides methods for setting and getting this piece of information. Simulink Block A Simulink Block is the wrapper of a (C++) Block. It provides a visual representation of it, with input and output ports and gives the possibility to connect it with other Simulink blocks through signals. The terms above come from this representation and map it to C++. Simulink Model A Simulink Model is a project composed of a set of Simulink Blocks interconnected by Signals. Simulink Library A Simulink Library is a container of a set of Blocks that populates the Simulink Library Browser . Every toolbox must be shipped with an associated Simulink Library file in order to expose its Blocks. S-Function There are many types of functions for implementing an algorithm wrapped by a Simulink Block. In Matlab terminology, these functions are referred as S-Functions . You can read more about the supported types in What type of S-Function should you use . In short S-Functions provide a sort of interface (through C callbacks) where a given number of functions need to be implemented. Simulink knows the name of these functions and calls them on demand. Block Mask A Simulink Block is just a square with input and output ports. It is possible to \"mask\" a Simulink Block in order to provide a user-friendly GUI that can be useful e.g. for setting Block parameters. The mask may contain buttons, sliders, check boxes, dropdown menus, etc. Software library A library is a file containing compiled code (functions, classes, etc.) which cannot be executed standalone. It can be either static or dynamic . Static libraries are meant to be embedded inside the executable that calls their symbols, instead the code of dynamic libraries (also called shared libraries) is only referenced inside the executable and called when needed. For grasping better this difference, if multiple executables link against the same static library, the same code is embedded inside all of them, resulting in bigger executables and code duplication. A dynamic library object instead can be shared by multiple executables that need only to know their location in the filesystem and which symbols they provide. Info You can find more detailed information about software libraries and linkers at this link . Plugin Library A plugin library is a particular type of a dynamic library. An executable can load dynamic libraries either at load time, i.e. when the executable is launched, or at run time, i.e. when needed during the execution. The libraries that can be loaded during run time are referred as plugins. Info On UNIX systems the load the a plugin is executed by a dlopen Overview of Simulink execution The core of the WB-Toolbox provides a framework capable of loading during runtime shared libraries. When the Simulink simulation starts, its engine assigns a deterministic order to the blocks of the Simulink Model. If one of these blocks is not contained in the system toolboxes, it needs to be associated to a S-Function that implements its logic. The toolbox provides a streamlined approach to implement these functions without the need of being an expert of the complex Simulink APIs. The blocks of our library are implemented in Simulink using the following S-Function block: What you need to know for the time being is that the name of the plugin library generated from the C++ code will be stored in the S-function parameters field. We provide a generic Level-2 MEX S-Function that reads this parameter and uses the library name name to dynamically load the dynamic shared library that contains the block's code. After the library is found in the filesystem and successfully loaded, Simulink allocates an object of the C++ class associated to the block functionality. Again, this information (the class name) is passed in the S-function parameters field. Develop the C++ plugin You already learned that Blocks are no more than regular C++ classes. They are not an exception, in fact all the components discussed until now are mapped to C++ classes or interfaces ( abstract classes ). The following resources provide further information about them: Blocks are implementations of the wbt::Block interface BlockInformation is defined in the wbt::BlockInformation interface Signals are mapped to the wbt::Signal class Blocks parameters are mapped to the wbt::Parameter class We need the following folder structure for the C++ project. Create already the empty files so the project can compile from the very first attempt. . \u251c\u2500\u2500 CMakeLists.txt \u251c\u2500\u2500 include \u2502 \u2514\u2500\u2500 SignalMath.h \u2514\u2500\u2500 src \u251c\u2500\u2500 Factory.cpp \u2514\u2500\u2500 SignalMath.cpp Info All the path of this tutorial will be relative to the root folder of the project. This means that if the directory tree above is stored in /home/foo/tutorial , when you read to go the ./build directory it means /home/foo/tutorial/build . Tip Bear in mind that this C++ class is independent from Simulink. Potentially, it can be called by a standalone C++ executable. Tip It is not mandatory to implement a new class for every Simulink Block. If they share a lot of code, a single class can be referenced by multiple Simulink Blocks and its behavior can be selected using parameters. CMake project for compiling the library You are free to use your favorite tool for compiling the project. We recommend CMake. If you are not an expert user of this tool, just follow the steps. The comments in the file should be enough to understand what it is happening. Fill the file CMakeLists.txt with the following content: cmake_minimum_required ( VERSION 3.5 ) project ( ExampleToolbox LANGUAGES CXX VERSION 0.1 ) # C++ standard set ( CMAKE_CXX_STANDARD 11 ) set ( CMAKE_CXX_STANDARD_REQUIRED ON ) # Export all symbols in Windows set ( CMAKE_WINDOWS_EXPORT_ALL_SYMBOLS ON ) # Tweak linker flags in Linux. # Matlab is very strict on missing symbols and by default ld do not warn if # something is missing. if ( UNIX AND NOT APPLE ) get_filename_component ( LINKER_BIN ${ CMAKE_LINKER } NAME ) if ( ${ LINKER_BIN } STREQUAL ld ) set ( CMAKE_SHARED_LINKER_FLAGS -Wl,--unresolved-symbols=report-all ) endif () endif () # =========== # C++ LIBRARY # =========== # Find the needed WBToolbox components: # - ToolboxCore contains the core classes such as Block and Signal # - ToolboxMex is required at runtime for loading the library from Simulink find_package ( WBToolbox 4 REQUIRED COMPONENTS ToolboxCore ToolboxMex ) # Find the project for the multiplatform support of plugin libraries. # It is shipped with WBToolbox and it should be already installed in your system. find_package ( shlibpp REQUIRED ) # Create the plugin library. This must be a SHARED library. add_library ( ExampleToolbox SHARED include/SignalMath.h src/SignalMath.cpp src/Factory.cpp ) # Manually set the name of the output library. This is not required and it # is done only for sake of clarity. set_target_properties ( ExampleToolbox PROPERTIES OUTPUT_NAME ExampleToolbox ) # Link the library with the Core component containing the core classes # and the target that provides the plugin support target_link_libraries ( ExampleToolbox WBToolbox::Core shlibpp::shlibpp ) # Setup the include directories target_include_directories ( ExampleToolbox PUBLIC $ BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/include $ INSTALL_INTERFACE:${CMAKE_INSTALL_INCLUDEDIR}/ExampleToolbox ) Note If your library needs to link against other libraries, use find_package to load their targets and then add them to the target_link_libraries directive. From the root folder of the project, execute: mkdir build cd build cmake .. cmake --build . You should now find in the ./build directories a new library file, which depending on your OS is: libExampleToolbox.so on Linux libExampleToolbox.dylib on macOS ExampleToolbox.dll on Windows This is the toolbox's plugin library which is loaded during runtime by the Engine. Implement the block logic The only Signal math block of our new toolbox will be implemented in a example::SignalMath C++ class. Header Here below the ./include/SignalMath.h header. Given the simple logic it should be straightforward to understand. The class inherits from the wbt::Block interface and implements some of its methods. Info The only mandatory method to implement is the wbt::Block::output . By default the other methods are dummy and they always return true . #ifndef EXAMPLE_SIGNALMATH_H #define EXAMPLE_SIGNALMATH_H #include Core/Block.h #include Core/BlockInformation.h #include memory #include string namespace example { class SignalMath ; } // namespace example class example :: SignalMath : public wbt :: Block { private : enum class Operation { ADDITION , SUBTRACTION , MULTIPLICATION , }; Operation m_operation ; public : static const std :: string ClassName ; SignalMath () = default ; ~ SignalMath () override = default ; unsigned numberOfParameters () override ; bool parseParameters ( wbt :: BlockInformation * blockInfo ) override ; bool configureSizeAndPorts ( wbt :: BlockInformation * blockInfo ) override ; bool initialize ( wbt :: BlockInformation * blockInfo ) override ; bool output ( const wbt :: BlockInformation * blockInfo ) override ; bool terminate ( const wbt :: BlockInformation * blockInfo ) override ; }; #endif // EXAMPLE_SIGNALMATH_H The ./src/SignalMath.cpp file is more interesting, let's split it in chunks. Parameters If you recall, BlockInformation is used by the Block for interfacing with the Engine. When this code is executed inside Simulink, the wbt::SimulinkBlockInformation implementation will perform the required operations calling Simulink APIs. #include SignalMath.h #include Core/Log.h #include Core/Parameter.h #include Core/Signal.h using namespace example ; unsigned SignalMath :: numberOfParameters () { // The base wbt::Block class needs parameters (e.g. the ClassName). // You must specify here how many more parameters this class needs. // Our example needs just one more: the operation to perform. return Block :: numberOfParameters () + 1 ; } // This method should let BlockInformation know the parameters metadata bool SignalMath :: parseParameters ( wbt :: BlockInformation * blockInfo ) { // Initialize information for our only parameter int rows = 1 ; int cols = 1 ; std :: string name = Operation ; // This label is used to access the param later unsigned index = Block :: numberOfParameters (); // Indices start from 0 wbt :: ParameterType type = wbt :: ParameterType :: STRING ; // Create the parameter wbt :: ParameterMetadata parameterMetadata ( type , index , rows , cols , name ); // Add the parameter metadata into the BlockInformation if ( ! blockInfo - addParameterMetadata ( parameterMetadata )) { wbtError Failed to store parameter metadata ; return false ; } // Ask to the BlockInformation interface to parse the parameters and store them into // the m_parameters variable. This variable is contained in the wbt::Block class. bool paramParsedOk = blockInfo - parseParameters ( m_parameters ); // Return the outcome of the parameter parsing. // If the parsing fails, the execution stops. return paramParsedOk ; } Configuration The configuration of the Block is performed in the following steps: The base class needs to be configured. It needs some parameters (e.g. the class name and the library name) and this call asks the Engine to parse them. The ports of the Block need to be defined. In this example the size is set as dynamic so that it accepts signals with any width. The wbt::BlockInformation::IOData class is used to store the data of all the ports. It is a struct containing two std::vectors . The data is then sent to the Engine through the BlockInformation interface. Info If needed, parameters can be accessed from this step. Refer to the initialization phase to understand how to gather them. Signal size Simulink has the support of inheriting the port size from the signal size, though use this feature only when strictly needed. In complex Simulink Models it might be difficult executing this size propagation, and fixing the Port size provides helpful constraints for the Engine. Important Be careful on memory allocations during this step. A temporary object is created only for configuration means, and then destroyed. All the allocated memory will be hereby deleted. bool SignalMath :: configureSizeAndPorts ( wbt :: BlockInformation * blockInfo ) { // The base wbt::Block class need to be configured if ( ! wbt :: Block :: configureSizeAndPorts ( blockInfo )) { return false ; } // Create data about input and output ports. wbt :: BlockInformation :: PortData input1 ; wbt :: BlockInformation :: PortData input2 ; wbt :: BlockInformation :: PortData output ; input1 = { /*portIndex=*/ 0 , std :: vector int { wbt :: Signal :: DynamicSize }, wbt :: DataType :: DOUBLE }; input2 = { /*portIndex=*/ 1 , std :: vector int { wbt :: Signal :: DynamicSize }, wbt :: DataType :: DOUBLE }; output = { /*portIndex=*/ 0 , std :: vector int { wbt :: Signal :: DynamicSize }, wbt :: DataType :: DOUBLE }; // Populate a structure with the overall input / output data wbt :: BlockInformation :: IOData ioData ; ioData . input . push_back ( input1 ); ioData . input . push_back ( input2 ); ioData . output . push_back ( output ); // Store this data into the BlockInformation if ( ! blockInfo - setIOPortsData ( ioData )) { wbtError Failed to configure input / output ports ; return false ; } return true ; } Initialization Info Starting from this step, memory persistence is guaranteed. In the initialization step, the input parameter that defines the operation is parsed. In this example the parameter is passed as a string. In the header a new enum class Operation was defined and here the related private member is properly initialized. Additional checks can be added, i.e. testing that both ports have the same width given that a dynamic size was previously assigned. Info In this case there's no need to allocate memory. If your class has buffers to initialize, this is the right time to do it. bool SignalMath :: initialize ( wbt :: BlockInformation * blockInfo ) { // The base wbt::Block class need to be initialized if ( ! Block :: initialize ( blockInfo )) { return false ; } // Parse the parameters if ( ! SignalMath :: parseParameters ( blockInfo )) { wbtError Failed to parse parameters. ; return false ; } // Read the Operation parameter and store it as a private member std :: string operation ; if ( ! m_parameters . getParameter ( Operation , operation )) { wbtError Failed to parse Operation parameter ; return false ; } // Check the content of the parameter if ( operation == Addition ) { m_operation = Operation :: ADDITION ; } else if ( operation == Subtraction ) { m_operation = Operation :: SUBTRACTION ; } else if ( operation == Multiplication ) { m_operation = Operation :: MULTIPLICATION ; } else { wbtError Operation operation not supported ; return false ; } // Check that the size of the input signals match if ( blockInfo - getInputPortWidth ( /*index=*/ 0 ) != blockInfo - getInputPortWidth ( /*index=*/ 1 )) { wbtError Input signals widths do not match ; return false ; } return true ; } Output The output method is where the real algorithm is implemented. The Signals are firstly gathered from the Engine using their index. The classes wbt::InputSignalPtr and wbt::OutputSignalPtr are particular typedef of the wbt::Signal class and they have the same methods. In the for loop the configured operation is performed and the result stored in the output signal. Note Note that input signals are read-only. You can write data only to the output signals objects. bool SignalMath :: output ( const wbt :: BlockInformation * blockInfo ) { // Get the input signals wbt :: InputSignalPtr input1 = blockInfo - getInputPortSignal ( /*index=*/ 0 ); wbt :: InputSignalPtr input2 = blockInfo - getInputPortSignal ( /*index=*/ 1 ); // Get the output signal wbt :: OutputSignalPtr output = blockInfo - getOutputPortSignal ( /*index=*/ 0 ); // Check the signal validity if ( ! input1 || ! input2 || ! output ) { wbtError Signals not valid ; return false ; } // Check the width of the output signal. // This is recommended for dynamically sized signals. if ( output - getWidth () != input1 - getWidth ()) { wbtError Output signal has a width of output - getWidth () while input signals have a width of input1 - getWidth (); return false ; } // Perform the given operation for ( unsigned i = 0 ; i output - getWidth (); ++ i ) { switch ( m_operation ) { case Operation :: ADDITION : output - set ( i , input1 - get double ( i ) + input2 - get double ( i )); break ; case Operation :: SUBTRACTION : output - set ( i , input1 - get double ( i ) - input2 - get double ( i )); break ; case Operation :: MULTIPLICATION : output - set ( i , input1 - get double ( i ) * input2 - get double ( i )); break ; } } return true ; } Terminate Given the simplicity of our Block, the terminate step is a dummy implementation. This method is reported just for the sake of clarity. It can be omitted since wbt::Block::terminate already provides the same dummy implementation. bool SignalMath :: terminate ( const wbt :: BlockInformation * /*blockInfo*/ ) { return true ; } Implement the plugin factory A plugin library usually contains multiple classes used for multiple Blocks. The sharedlibpp tool for plugins requires declaring what classes are part of the plugin. This operation is done in the ./include/Factory.cpp file: #include SignalMath.h // Class factory API #include shlibpp/SharedLibraryClassApi.h // Add the example::SignalMath class to the plugin factory SHLIBPP_DEFINE_SHARED_SUBCLASS ( SignalMath , example :: SignalMath , wbt :: Block ); The SHLIBPP_DEFINE_SHARED_SUBCLASS macro needs the following three arguments: A label used to extract the class from the plugin library The class of the block The base class of the block The only interesting part here is the label. Keep this name in mind because we need to know it later in the Simulink section. If everything works as expected, the library is now ready and can be compiled again: cd build cmake --build . Tip Simulink will open this library at the beginning of the simulation loop and it needs to find it from the filesystem. Be sure that the ./build folder is in the searching path of your dynamic linker. In the supported OSs you should add it to: - Linux LD_LIBRARY_PATH - macOS DYLIB_LIBRARY_PATH - Windows Path Matlab and Simulink Once the C++ library is ready, the classes can be wrapped by a Simulink Block. If, as in this case, there's no existing Simulink Library to which the new block can be added, some extra step to create a new one is necessary. We're going to store the files discussed in this section in the ./matlab folder, obtaining at the end the following project structure: . \u251c\u2500\u2500 CMakeLists.txt \u251c\u2500\u2500 include \u2502 \u2514\u2500\u2500 SignalMath.h \u251c\u2500\u2500 matlab \u2502 \u251c\u2500\u2500 ExampleToolbox.slx \u2502 \u251c\u2500\u2500 Model.mdl \u2502 \u2514\u2500\u2500 slblocks.m \u2514\u2500\u2500 src \u251c\u2500\u2500 Factory.cpp \u2514\u2500\u2500 SignalMath.cpp ExampleToolbox.slx is the Simulink Library slblocks.m is a m script necessary for loading external Simulink Libraries into the Simulink Library Browser Model.mdl is a Simulink Model for testing the Block Create an new Simulink Library The first step is creating a new Simulink Library. Open the Simulink Start Page and create a Blank Library. Save it in ./matlab/ExampleToolbox.slx . In order to populate the Simulink Library Browser , you need to create a slblocks.m file with the following content: function blkStruct = slblocks Browser . Library = ExampleToolbox ; Browser . Name = Example Toolbox ; Browser . IsFlat = 0 ; blkStruct . Browser = Browser ; As explained in the official documentation , we also need to modify a property of the library file: set_param ( ExampleToolbox , EnableLBRepository , on ); If you followed these steps, the new library should be ready. Be sure that the ./matlab folder is in the Matlab path , then open the Simulink Library Browser and press F5 . You should now see the empty Example Toolbox entry. Note In order to add a folder to the path , you can either browse it from the Matlab tree view making it the current folder, or executing addpath('/path/of/the/folder') . Find more details at What Is the MATLAB Search Path? . Info Every time you close the library, Matlab locks it. Press the lock icon in the bottom left corner to unlock the library. Add a block Open the library and add a new S-Function block with the following parameters: The S-function name is the name of the generic S-Function that Whole Body Toolbox provides The S-function parameters are the parameters passed to the S-Function. The first two are required by wbt::Block , and the third one is the parameter of our example::SignalMath class: 'SignalMath' is the label we used in Factory.cpp 'ExampleToolbox' is the name of the plugin library. It must match the OUTPUT_NAME we assigned in CMakeLists.txt 'Addition' is the kind of operation we want this block to perform Press OK and save the library. If you insert wrong information, like a wrong number of parameters or parameters with a wrong type or content, the wbtError s we added in the C++ class should provide more details. Create a test Simulink Model Now it's time for finally testing all our work. Create a new Blank Model and populate it with the following blocks: Then press the Play icon, and the Display connected to the block output should show the result of the addition. Create a block mask The type of the operation is defined as a parameter of the S-Function block. It is not very intuitive changing it in this way. Beyond the effort of changing the string, we should remember exactly what parameters the block accepts. This limitation can be overcome masking the block, that means providing a GUI to the block. Right-click the block from the Example Toolbox library and press Mask Create Mask . In the Icon Ports tab, fill the Icon drawing commands with: disp ( Signal Math ) port_label ( input , 1 , Input 1 ) port_label ( input , 2 , Input 2 ) port_label ( output , 1 , Output ) Then, in the Parameters Dialog tab, add a Popup and fill it obtaining the following status: Note Note that the evaluate attribute has been unchecked. When a Popup is not evaluated, its variable ( operation in this case) will contain the string of the selected option. Instead, if it is evaluated, it contains a 0-based index. Save the library and substitute the new Block in the Simulink Model. You can now select the operation double-clicking the block and changing the popup menu entry. Final comments Whole Body Toolbox provides great abstraction capabilities for wrapping C and C++ algorithms to Simulink Blocks. You don't need to be a Simulink expert for this kind of operation, all the machinery is hidden under the hood. Possibilities are endless. Despite Whole Body Toolbox was originally designed for robotic applications, it is interesting discovering how many new toolboxes can be created on top of it. The v4 release provides the first experimental support to external usage. The toolbox APIs are already mature and reached an acceptable stability after being developed, tested, and refined for many years. We are eager to hear your feedback in order to have a great v1.0 release of the standalone toolbox core! If you find bugs or want to propose enhancements, please fill a new Issue .","title":"Tutorial: create a new library"},{"location":"create_new_library/#tutorial-how-to-create-a-new-library","text":"This guide describes how to use the core infrastructure of the Whole Body Toolbox for creating a new toolbox Toolbox Example . It will contain a single block Signal math with the following specifications: Accepts two input signals Performs element-wise operations: sum, subtraction, multiplication Allows to select the operation with a user friendly GUI (mask) Produces an output signal with the result of the operation Despite it is a very trivial example, it shows how to structure both the C++ and the Matlab components of a toolbox. From this starting point is then possible to build more complex architectures which might need e.g. to be split in many parts or to link against third-party libraries. Toolbox Example project You can find the files of this example in the example folder. Info Until v4 this core machinery is shipped together with our robotics framework. We're currently working on splitting the toolbox components for providing a standalone process. Stay tuned for upcoming news!","title":"Tutorial: How to create a new library"},{"location":"create_new_library/#introduction","text":"Before jumping in the example of this tutorial, in this section you will find helpful information useful to grasp the key ideas about the toolbox and a refreshing of common terms and patterns used in programming.","title":"Introduction"},{"location":"create_new_library/#algorithm-specifications","text":"The execution of a generic algorithm can be split in the following basic phases: Configuration Initialization Step Termination In the configuration phase the algorithm can, for instance, read parameters and specify details about its inputs and outputs. During the initialization it might need to allocate resources. When everything is ready, the simulation starts and on every cycle of the loop the algorithm computes a step. Before finishing the simulation, in the termination step the resources that are not anymore needed can be deallocated and final operations can be executed.","title":"Algorithm specifications"},{"location":"create_new_library/#terminology","text":"There are few key components which are part of the core infrastructure, and it is important they are clear from the very beginning. Note This project has strong roots with Simulink. Despite it is not anymore strictly related to it, the structure keeps as inheritance its terminology.","title":"Terminology"},{"location":"create_new_library/#block","text":"The Block is the main component of the toolbox. You may think of it as a wrapper for a generic algorithm. It provides support of all the phases discussed above.","title":"Block"},{"location":"create_new_library/#port","text":"Blocks need to interface with the outside for reading input data and writing their results. Ports are attached to the Block and let data flow in and out from it. They have properties like the accepted data type and they are characterized by a size.","title":"Port"},{"location":"create_new_library/#signal","text":"A Signal is the generalization of a buffer. It can be plugged to multiple Ports and allows sharing data between them. Similarly to Ports, a Signal has a data type and a width. When a Signal is connected to a Port, their dimension must match.","title":"Signal"},{"location":"create_new_library/#engine","text":"The engine is the framework that calls and executes the code implementing the Blocks. We currently provide support for Simulink and Simulink Coder. Alternative engines might be Scilab or even standalone C++ code.","title":"Engine"},{"location":"create_new_library/#blockinformation","text":"BlockInformation is the interface between a Block and the engine that executes its code. Despite blocks are not aware of what engine is executing them, blocks and engine need to exchange information such as user parameters and Port data. BlockInformation provides methods for setting and getting this piece of information.","title":"BlockInformation"},{"location":"create_new_library/#simulink-block","text":"A Simulink Block is the wrapper of a (C++) Block. It provides a visual representation of it, with input and output ports and gives the possibility to connect it with other Simulink blocks through signals. The terms above come from this representation and map it to C++.","title":"Simulink Block"},{"location":"create_new_library/#simulink-model","text":"A Simulink Model is a project composed of a set of Simulink Blocks interconnected by Signals.","title":"Simulink Model"},{"location":"create_new_library/#simulink-library","text":"A Simulink Library is a container of a set of Blocks that populates the Simulink Library Browser . Every toolbox must be shipped with an associated Simulink Library file in order to expose its Blocks.","title":"Simulink Library"},{"location":"create_new_library/#s-function","text":"There are many types of functions for implementing an algorithm wrapped by a Simulink Block. In Matlab terminology, these functions are referred as S-Functions . You can read more about the supported types in What type of S-Function should you use . In short S-Functions provide a sort of interface (through C callbacks) where a given number of functions need to be implemented. Simulink knows the name of these functions and calls them on demand.","title":"S-Function"},{"location":"create_new_library/#block-mask","text":"A Simulink Block is just a square with input and output ports. It is possible to \"mask\" a Simulink Block in order to provide a user-friendly GUI that can be useful e.g. for setting Block parameters. The mask may contain buttons, sliders, check boxes, dropdown menus, etc.","title":"Block Mask"},{"location":"create_new_library/#software-library","text":"A library is a file containing compiled code (functions, classes, etc.) which cannot be executed standalone. It can be either static or dynamic . Static libraries are meant to be embedded inside the executable that calls their symbols, instead the code of dynamic libraries (also called shared libraries) is only referenced inside the executable and called when needed. For grasping better this difference, if multiple executables link against the same static library, the same code is embedded inside all of them, resulting in bigger executables and code duplication. A dynamic library object instead can be shared by multiple executables that need only to know their location in the filesystem and which symbols they provide. Info You can find more detailed information about software libraries and linkers at this link .","title":"Software library"},{"location":"create_new_library/#plugin-library","text":"A plugin library is a particular type of a dynamic library. An executable can load dynamic libraries either at load time, i.e. when the executable is launched, or at run time, i.e. when needed during the execution. The libraries that can be loaded during run time are referred as plugins. Info On UNIX systems the load the a plugin is executed by a dlopen","title":"Plugin Library"},{"location":"create_new_library/#overview-of-simulink-execution","text":"The core of the WB-Toolbox provides a framework capable of loading during runtime shared libraries. When the Simulink simulation starts, its engine assigns a deterministic order to the blocks of the Simulink Model. If one of these blocks is not contained in the system toolboxes, it needs to be associated to a S-Function that implements its logic. The toolbox provides a streamlined approach to implement these functions without the need of being an expert of the complex Simulink APIs. The blocks of our library are implemented in Simulink using the following S-Function block: What you need to know for the time being is that the name of the plugin library generated from the C++ code will be stored in the S-function parameters field. We provide a generic Level-2 MEX S-Function that reads this parameter and uses the library name name to dynamically load the dynamic shared library that contains the block's code. After the library is found in the filesystem and successfully loaded, Simulink allocates an object of the C++ class associated to the block functionality. Again, this information (the class name) is passed in the S-function parameters field.","title":"Overview of Simulink execution"},{"location":"create_new_library/#develop-the-c-plugin","text":"You already learned that Blocks are no more than regular C++ classes. They are not an exception, in fact all the components discussed until now are mapped to C++ classes or interfaces ( abstract classes ). The following resources provide further information about them: Blocks are implementations of the wbt::Block interface BlockInformation is defined in the wbt::BlockInformation interface Signals are mapped to the wbt::Signal class Blocks parameters are mapped to the wbt::Parameter class We need the following folder structure for the C++ project. Create already the empty files so the project can compile from the very first attempt. . \u251c\u2500\u2500 CMakeLists.txt \u251c\u2500\u2500 include \u2502 \u2514\u2500\u2500 SignalMath.h \u2514\u2500\u2500 src \u251c\u2500\u2500 Factory.cpp \u2514\u2500\u2500 SignalMath.cpp Info All the path of this tutorial will be relative to the root folder of the project. This means that if the directory tree above is stored in /home/foo/tutorial , when you read to go the ./build directory it means /home/foo/tutorial/build . Tip Bear in mind that this C++ class is independent from Simulink. Potentially, it can be called by a standalone C++ executable. Tip It is not mandatory to implement a new class for every Simulink Block. If they share a lot of code, a single class can be referenced by multiple Simulink Blocks and its behavior can be selected using parameters.","title":"Develop the C++ plugin"},{"location":"create_new_library/#cmake-project-for-compiling-the-library","text":"You are free to use your favorite tool for compiling the project. We recommend CMake. If you are not an expert user of this tool, just follow the steps. The comments in the file should be enough to understand what it is happening. Fill the file CMakeLists.txt with the following content: cmake_minimum_required ( VERSION 3.5 ) project ( ExampleToolbox LANGUAGES CXX VERSION 0.1 ) # C++ standard set ( CMAKE_CXX_STANDARD 11 ) set ( CMAKE_CXX_STANDARD_REQUIRED ON ) # Export all symbols in Windows set ( CMAKE_WINDOWS_EXPORT_ALL_SYMBOLS ON ) # Tweak linker flags in Linux. # Matlab is very strict on missing symbols and by default ld do not warn if # something is missing. if ( UNIX AND NOT APPLE ) get_filename_component ( LINKER_BIN ${ CMAKE_LINKER } NAME ) if ( ${ LINKER_BIN } STREQUAL ld ) set ( CMAKE_SHARED_LINKER_FLAGS -Wl,--unresolved-symbols=report-all ) endif () endif () # =========== # C++ LIBRARY # =========== # Find the needed WBToolbox components: # - ToolboxCore contains the core classes such as Block and Signal # - ToolboxMex is required at runtime for loading the library from Simulink find_package ( WBToolbox 4 REQUIRED COMPONENTS ToolboxCore ToolboxMex ) # Find the project for the multiplatform support of plugin libraries. # It is shipped with WBToolbox and it should be already installed in your system. find_package ( shlibpp REQUIRED ) # Create the plugin library. This must be a SHARED library. add_library ( ExampleToolbox SHARED include/SignalMath.h src/SignalMath.cpp src/Factory.cpp ) # Manually set the name of the output library. This is not required and it # is done only for sake of clarity. set_target_properties ( ExampleToolbox PROPERTIES OUTPUT_NAME ExampleToolbox ) # Link the library with the Core component containing the core classes # and the target that provides the plugin support target_link_libraries ( ExampleToolbox WBToolbox::Core shlibpp::shlibpp ) # Setup the include directories target_include_directories ( ExampleToolbox PUBLIC $ BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/include $ INSTALL_INTERFACE:${CMAKE_INSTALL_INCLUDEDIR}/ExampleToolbox ) Note If your library needs to link against other libraries, use find_package to load their targets and then add them to the target_link_libraries directive. From the root folder of the project, execute: mkdir build cd build cmake .. cmake --build . You should now find in the ./build directories a new library file, which depending on your OS is: libExampleToolbox.so on Linux libExampleToolbox.dylib on macOS ExampleToolbox.dll on Windows This is the toolbox's plugin library which is loaded during runtime by the Engine.","title":"CMake project for compiling the library"},{"location":"create_new_library/#implement-the-block-logic","text":"The only Signal math block of our new toolbox will be implemented in a example::SignalMath C++ class.","title":"Implement the block logic"},{"location":"create_new_library/#header","text":"Here below the ./include/SignalMath.h header. Given the simple logic it should be straightforward to understand. The class inherits from the wbt::Block interface and implements some of its methods. Info The only mandatory method to implement is the wbt::Block::output . By default the other methods are dummy and they always return true . #ifndef EXAMPLE_SIGNALMATH_H #define EXAMPLE_SIGNALMATH_H #include Core/Block.h #include Core/BlockInformation.h #include memory #include string namespace example { class SignalMath ; } // namespace example class example :: SignalMath : public wbt :: Block { private : enum class Operation { ADDITION , SUBTRACTION , MULTIPLICATION , }; Operation m_operation ; public : static const std :: string ClassName ; SignalMath () = default ; ~ SignalMath () override = default ; unsigned numberOfParameters () override ; bool parseParameters ( wbt :: BlockInformation * blockInfo ) override ; bool configureSizeAndPorts ( wbt :: BlockInformation * blockInfo ) override ; bool initialize ( wbt :: BlockInformation * blockInfo ) override ; bool output ( const wbt :: BlockInformation * blockInfo ) override ; bool terminate ( const wbt :: BlockInformation * blockInfo ) override ; }; #endif // EXAMPLE_SIGNALMATH_H The ./src/SignalMath.cpp file is more interesting, let's split it in chunks.","title":"Header"},{"location":"create_new_library/#parameters","text":"If you recall, BlockInformation is used by the Block for interfacing with the Engine. When this code is executed inside Simulink, the wbt::SimulinkBlockInformation implementation will perform the required operations calling Simulink APIs. #include SignalMath.h #include Core/Log.h #include Core/Parameter.h #include Core/Signal.h using namespace example ; unsigned SignalMath :: numberOfParameters () { // The base wbt::Block class needs parameters (e.g. the ClassName). // You must specify here how many more parameters this class needs. // Our example needs just one more: the operation to perform. return Block :: numberOfParameters () + 1 ; } // This method should let BlockInformation know the parameters metadata bool SignalMath :: parseParameters ( wbt :: BlockInformation * blockInfo ) { // Initialize information for our only parameter int rows = 1 ; int cols = 1 ; std :: string name = Operation ; // This label is used to access the param later unsigned index = Block :: numberOfParameters (); // Indices start from 0 wbt :: ParameterType type = wbt :: ParameterType :: STRING ; // Create the parameter wbt :: ParameterMetadata parameterMetadata ( type , index , rows , cols , name ); // Add the parameter metadata into the BlockInformation if ( ! blockInfo - addParameterMetadata ( parameterMetadata )) { wbtError Failed to store parameter metadata ; return false ; } // Ask to the BlockInformation interface to parse the parameters and store them into // the m_parameters variable. This variable is contained in the wbt::Block class. bool paramParsedOk = blockInfo - parseParameters ( m_parameters ); // Return the outcome of the parameter parsing. // If the parsing fails, the execution stops. return paramParsedOk ; }","title":"Parameters"},{"location":"create_new_library/#configuration","text":"The configuration of the Block is performed in the following steps: The base class needs to be configured. It needs some parameters (e.g. the class name and the library name) and this call asks the Engine to parse them. The ports of the Block need to be defined. In this example the size is set as dynamic so that it accepts signals with any width. The wbt::BlockInformation::IOData class is used to store the data of all the ports. It is a struct containing two std::vectors . The data is then sent to the Engine through the BlockInformation interface. Info If needed, parameters can be accessed from this step. Refer to the initialization phase to understand how to gather them. Signal size Simulink has the support of inheriting the port size from the signal size, though use this feature only when strictly needed. In complex Simulink Models it might be difficult executing this size propagation, and fixing the Port size provides helpful constraints for the Engine. Important Be careful on memory allocations during this step. A temporary object is created only for configuration means, and then destroyed. All the allocated memory will be hereby deleted. bool SignalMath :: configureSizeAndPorts ( wbt :: BlockInformation * blockInfo ) { // The base wbt::Block class need to be configured if ( ! wbt :: Block :: configureSizeAndPorts ( blockInfo )) { return false ; } // Create data about input and output ports. wbt :: BlockInformation :: PortData input1 ; wbt :: BlockInformation :: PortData input2 ; wbt :: BlockInformation :: PortData output ; input1 = { /*portIndex=*/ 0 , std :: vector int { wbt :: Signal :: DynamicSize }, wbt :: DataType :: DOUBLE }; input2 = { /*portIndex=*/ 1 , std :: vector int { wbt :: Signal :: DynamicSize }, wbt :: DataType :: DOUBLE }; output = { /*portIndex=*/ 0 , std :: vector int { wbt :: Signal :: DynamicSize }, wbt :: DataType :: DOUBLE }; // Populate a structure with the overall input / output data wbt :: BlockInformation :: IOData ioData ; ioData . input . push_back ( input1 ); ioData . input . push_back ( input2 ); ioData . output . push_back ( output ); // Store this data into the BlockInformation if ( ! blockInfo - setIOPortsData ( ioData )) { wbtError Failed to configure input / output ports ; return false ; } return true ; }","title":"Configuration"},{"location":"create_new_library/#initialization","text":"Info Starting from this step, memory persistence is guaranteed. In the initialization step, the input parameter that defines the operation is parsed. In this example the parameter is passed as a string. In the header a new enum class Operation was defined and here the related private member is properly initialized. Additional checks can be added, i.e. testing that both ports have the same width given that a dynamic size was previously assigned. Info In this case there's no need to allocate memory. If your class has buffers to initialize, this is the right time to do it. bool SignalMath :: initialize ( wbt :: BlockInformation * blockInfo ) { // The base wbt::Block class need to be initialized if ( ! Block :: initialize ( blockInfo )) { return false ; } // Parse the parameters if ( ! SignalMath :: parseParameters ( blockInfo )) { wbtError Failed to parse parameters. ; return false ; } // Read the Operation parameter and store it as a private member std :: string operation ; if ( ! m_parameters . getParameter ( Operation , operation )) { wbtError Failed to parse Operation parameter ; return false ; } // Check the content of the parameter if ( operation == Addition ) { m_operation = Operation :: ADDITION ; } else if ( operation == Subtraction ) { m_operation = Operation :: SUBTRACTION ; } else if ( operation == Multiplication ) { m_operation = Operation :: MULTIPLICATION ; } else { wbtError Operation operation not supported ; return false ; } // Check that the size of the input signals match if ( blockInfo - getInputPortWidth ( /*index=*/ 0 ) != blockInfo - getInputPortWidth ( /*index=*/ 1 )) { wbtError Input signals widths do not match ; return false ; } return true ; }","title":"Initialization"},{"location":"create_new_library/#output","text":"The output method is where the real algorithm is implemented. The Signals are firstly gathered from the Engine using their index. The classes wbt::InputSignalPtr and wbt::OutputSignalPtr are particular typedef of the wbt::Signal class and they have the same methods. In the for loop the configured operation is performed and the result stored in the output signal. Note Note that input signals are read-only. You can write data only to the output signals objects. bool SignalMath :: output ( const wbt :: BlockInformation * blockInfo ) { // Get the input signals wbt :: InputSignalPtr input1 = blockInfo - getInputPortSignal ( /*index=*/ 0 ); wbt :: InputSignalPtr input2 = blockInfo - getInputPortSignal ( /*index=*/ 1 ); // Get the output signal wbt :: OutputSignalPtr output = blockInfo - getOutputPortSignal ( /*index=*/ 0 ); // Check the signal validity if ( ! input1 || ! input2 || ! output ) { wbtError Signals not valid ; return false ; } // Check the width of the output signal. // This is recommended for dynamically sized signals. if ( output - getWidth () != input1 - getWidth ()) { wbtError Output signal has a width of output - getWidth () while input signals have a width of input1 - getWidth (); return false ; } // Perform the given operation for ( unsigned i = 0 ; i output - getWidth (); ++ i ) { switch ( m_operation ) { case Operation :: ADDITION : output - set ( i , input1 - get double ( i ) + input2 - get double ( i )); break ; case Operation :: SUBTRACTION : output - set ( i , input1 - get double ( i ) - input2 - get double ( i )); break ; case Operation :: MULTIPLICATION : output - set ( i , input1 - get double ( i ) * input2 - get double ( i )); break ; } } return true ; }","title":"Output"},{"location":"create_new_library/#terminate","text":"Given the simplicity of our Block, the terminate step is a dummy implementation. This method is reported just for the sake of clarity. It can be omitted since wbt::Block::terminate already provides the same dummy implementation. bool SignalMath :: terminate ( const wbt :: BlockInformation * /*blockInfo*/ ) { return true ; }","title":"Terminate"},{"location":"create_new_library/#implement-the-plugin-factory","text":"A plugin library usually contains multiple classes used for multiple Blocks. The sharedlibpp tool for plugins requires declaring what classes are part of the plugin. This operation is done in the ./include/Factory.cpp file: #include SignalMath.h // Class factory API #include shlibpp/SharedLibraryClassApi.h // Add the example::SignalMath class to the plugin factory SHLIBPP_DEFINE_SHARED_SUBCLASS ( SignalMath , example :: SignalMath , wbt :: Block ); The SHLIBPP_DEFINE_SHARED_SUBCLASS macro needs the following three arguments: A label used to extract the class from the plugin library The class of the block The base class of the block The only interesting part here is the label. Keep this name in mind because we need to know it later in the Simulink section. If everything works as expected, the library is now ready and can be compiled again: cd build cmake --build . Tip Simulink will open this library at the beginning of the simulation loop and it needs to find it from the filesystem. Be sure that the ./build folder is in the searching path of your dynamic linker. In the supported OSs you should add it to: - Linux LD_LIBRARY_PATH - macOS DYLIB_LIBRARY_PATH - Windows Path","title":"Implement the plugin factory"},{"location":"create_new_library/#matlab-and-simulink","text":"Once the C++ library is ready, the classes can be wrapped by a Simulink Block. If, as in this case, there's no existing Simulink Library to which the new block can be added, some extra step to create a new one is necessary. We're going to store the files discussed in this section in the ./matlab folder, obtaining at the end the following project structure: . \u251c\u2500\u2500 CMakeLists.txt \u251c\u2500\u2500 include \u2502 \u2514\u2500\u2500 SignalMath.h \u251c\u2500\u2500 matlab \u2502 \u251c\u2500\u2500 ExampleToolbox.slx \u2502 \u251c\u2500\u2500 Model.mdl \u2502 \u2514\u2500\u2500 slblocks.m \u2514\u2500\u2500 src \u251c\u2500\u2500 Factory.cpp \u2514\u2500\u2500 SignalMath.cpp ExampleToolbox.slx is the Simulink Library slblocks.m is a m script necessary for loading external Simulink Libraries into the Simulink Library Browser Model.mdl is a Simulink Model for testing the Block","title":"Matlab and Simulink"},{"location":"create_new_library/#create-an-new-simulink-library","text":"The first step is creating a new Simulink Library. Open the Simulink Start Page and create a Blank Library. Save it in ./matlab/ExampleToolbox.slx . In order to populate the Simulink Library Browser , you need to create a slblocks.m file with the following content: function blkStruct = slblocks Browser . Library = ExampleToolbox ; Browser . Name = Example Toolbox ; Browser . IsFlat = 0 ; blkStruct . Browser = Browser ; As explained in the official documentation , we also need to modify a property of the library file: set_param ( ExampleToolbox , EnableLBRepository , on ); If you followed these steps, the new library should be ready. Be sure that the ./matlab folder is in the Matlab path , then open the Simulink Library Browser and press F5 . You should now see the empty Example Toolbox entry. Note In order to add a folder to the path , you can either browse it from the Matlab tree view making it the current folder, or executing addpath('/path/of/the/folder') . Find more details at What Is the MATLAB Search Path? . Info Every time you close the library, Matlab locks it. Press the lock icon in the bottom left corner to unlock the library.","title":"Create an new Simulink Library"},{"location":"create_new_library/#add-a-block","text":"Open the library and add a new S-Function block with the following parameters: The S-function name is the name of the generic S-Function that Whole Body Toolbox provides The S-function parameters are the parameters passed to the S-Function. The first two are required by wbt::Block , and the third one is the parameter of our example::SignalMath class: 'SignalMath' is the label we used in Factory.cpp 'ExampleToolbox' is the name of the plugin library. It must match the OUTPUT_NAME we assigned in CMakeLists.txt 'Addition' is the kind of operation we want this block to perform Press OK and save the library. If you insert wrong information, like a wrong number of parameters or parameters with a wrong type or content, the wbtError s we added in the C++ class should provide more details.","title":"Add a block"},{"location":"create_new_library/#create-a-test-simulink-model","text":"Now it's time for finally testing all our work. Create a new Blank Model and populate it with the following blocks: Then press the Play icon, and the Display connected to the block output should show the result of the addition.","title":"Create a test Simulink Model"},{"location":"create_new_library/#create-a-block-mask","text":"The type of the operation is defined as a parameter of the S-Function block. It is not very intuitive changing it in this way. Beyond the effort of changing the string, we should remember exactly what parameters the block accepts. This limitation can be overcome masking the block, that means providing a GUI to the block. Right-click the block from the Example Toolbox library and press Mask Create Mask . In the Icon Ports tab, fill the Icon drawing commands with: disp ( Signal Math ) port_label ( input , 1 , Input 1 ) port_label ( input , 2 , Input 2 ) port_label ( output , 1 , Output ) Then, in the Parameters Dialog tab, add a Popup and fill it obtaining the following status: Note Note that the evaluate attribute has been unchecked. When a Popup is not evaluated, its variable ( operation in this case) will contain the string of the selected option. Instead, if it is evaluated, it contains a 0-based index. Save the library and substitute the new Block in the Simulink Model. You can now select the operation double-clicking the block and changing the popup menu entry.","title":"Create a block mask"},{"location":"create_new_library/#final-comments","text":"Whole Body Toolbox provides great abstraction capabilities for wrapping C and C++ algorithms to Simulink Blocks. You don't need to be a Simulink expert for this kind of operation, all the machinery is hidden under the hood. Possibilities are endless. Despite Whole Body Toolbox was originally designed for robotic applications, it is interesting discovering how many new toolboxes can be created on top of it. The v4 release provides the first experimental support to external usage. The toolbox APIs are already mature and reached an acceptable stability after being developed, tested, and refined for many years. We are eager to hear your feedback in order to have a great v1.0 release of the standalone toolbox core! If you find bugs or want to propose enhancements, please fill a new Issue .","title":"Final comments"},{"location":"getting-started/","text":"Environment variables The following environment variables must be specified: YARP_ROBOT_NAME YARP_DATA_DIRS Tip: launch Matlab from the command line The environment variables stored in the .bashrc or .bash_profile files are automatically loaded. Store here additional variables if needed. Tip: launch Matlab from the desktop launcher You can store environment variables from the Matlab command line using the setenv function. Creating a model Before using or creating a new model keep in mind that WB-Toolbox is discrete in principle and your simulation should be discrete as well. By going to Simulation Configuration Parameters Solver you should change the solver options to Fixed Step and use a discrete (no continuous states) solver. In order to start dragging and dropping blocks from the WB-Toolbox , open the Simulink Library Browser and search for Whole Body Toolbox in the tree view.","title":"Getting started"},{"location":"getting-started/#environment-variables","text":"The following environment variables must be specified: YARP_ROBOT_NAME YARP_DATA_DIRS Tip: launch Matlab from the command line The environment variables stored in the .bashrc or .bash_profile files are automatically loaded. Store here additional variables if needed. Tip: launch Matlab from the desktop launcher You can store environment variables from the Matlab command line using the setenv function.","title":"Environment variables"},{"location":"getting-started/#creating-a-model","text":"Before using or creating a new model keep in mind that WB-Toolbox is discrete in principle and your simulation should be discrete as well. By going to Simulation Configuration Parameters Solver you should change the solver options to Fixed Step and use a discrete (no continuous states) solver. In order to start dragging and dropping blocks from the WB-Toolbox , open the Simulink Library Browser and search for Whole Body Toolbox in the tree view.","title":"Creating a model"},{"location":"install/","text":"Install Disclaimer WB-Toolbox has been widely tested on Ubuntu 16:04 and Ubuntu 18.04 with Matlab R2017b . If you face any issue either with your OS or Matlab version, please submit an Issue . Requirements Matlab 7.1+ and Simulink: tested with Matlab R2017b , R2016b YARP compiled as shared library (default behavior) iDynTree YCM Supported Operating Systems: Linux, macOS, Windows Optional requirements iCub Gazebo Simulator gazebo_yarp_plugins qpOASES Installation For a simplified installation procedure, jump to Install using the robotology-superbuild . Warning The following instructions are for Unix-like systems, but they work similarly on other operating systems. Dependencies Install the required and the optional dependencies by following their installation instructions. These instructions need that YARP , iDynTree and YCM packages can be found by CMake using find_package . Warning If an optional dependency is not found, the classes depending on it are not compiled. However, in the Simulink Library the block does not disappear. It will just not work, raising an appropriate error. Setup Matlab Make sure that you have MATLAB and Simulink properly installed and running. CMake needs to find the Matlab installation folder in order to link the sources against its libraries. Make sure that CMake is able to find your Matlab installation , or manually set the Matlab_ROOT_DIR environment variable if needed. After this, check that the MEX compiler for MATLAB is properly configured and working. You can try compiling some of the MATLAB C code examples as described in the mex official documentation . Download, build and install If all the dependencies are met, proceed with the following instructions: git clone https://github.com/robotology/wb-toolbox.git mkdir -p wb-toolbox/build cd wb-toolbox/build cmake .. -DCMAKE_INSTALL_PREFIX = install-prefix cmake --build . --config Release cmake --build . --config Release --target install Note From now on, this guide refers to your install directory with the variable install-prefix . Every time you see this variable, you should substitute the absolute install path. Configuration Matlab In order to use the WB-Toolbox in Matlab you have to add some folders to the Matlab path. If you usually launch Matlab from the command line, exporting the following environment variable should be enough: export MATLABPATH = install-prefix /mex: install-prefix /share/WBToolbox: install-prefix /share/WBToolbox/images If, instead, you use the desktop launcher, a non-persistent Matlab configuration is the following: addpath ([ install-prefix / mex ]) addpath ( genpath ([ install-prefix / share / WBToolbox ])) We also provide for the latter scenario a persistent configuration of WB-Toolbox . After the installation run once the startup_wbitoolbox.m script that you can find in the install-prefix /share/WBToolbox directory. It will place a file pathdef.m in your userpath that loads the right variables to Matlab's environment. Note that this usage assumes that Matlab is always launched from the userpath folder . Environment Each robot that can be used through WB-Toolbox has its own configuration files. WB-Toolbox uses the YARP 's ResourceFinder for finding files in the file system. You should thus follow the related instructions to properly configure your installation (e.g. setting the YARP_DATA_DIRS and YARP_ROBOT_NAME variables). Install using the robotology-superbuild The robotology/robotology-superbuild provides an easy way for users to setup an environment by downloading, compiling, installing all the projects together. Follow the superbuild installation instructions and enable the ROBOTOLOGY_ENABLE_DYNAMICS profile. If WB-Toolbox is not downloaded and built, check that the ROBOTOLOGY_USES_MATLAB is ON and the ROBOTOLOGY_NOT_USE_SIMULINK is OFF . The configuration should be straightforward following the Configure your environment and Matlab sections.","title":"Install"},{"location":"install/#install","text":"Disclaimer WB-Toolbox has been widely tested on Ubuntu 16:04 and Ubuntu 18.04 with Matlab R2017b . If you face any issue either with your OS or Matlab version, please submit an Issue .","title":"Install"},{"location":"install/#requirements","text":"Matlab 7.1+ and Simulink: tested with Matlab R2017b , R2016b YARP compiled as shared library (default behavior) iDynTree YCM Supported Operating Systems: Linux, macOS, Windows","title":"Requirements"},{"location":"install/#optional-requirements","text":"iCub Gazebo Simulator gazebo_yarp_plugins qpOASES","title":"Optional requirements"},{"location":"install/#installation","text":"For a simplified installation procedure, jump to Install using the robotology-superbuild . Warning The following instructions are for Unix-like systems, but they work similarly on other operating systems.","title":"Installation"},{"location":"install/#dependencies","text":"Install the required and the optional dependencies by following their installation instructions. These instructions need that YARP , iDynTree and YCM packages can be found by CMake using find_package . Warning If an optional dependency is not found, the classes depending on it are not compiled. However, in the Simulink Library the block does not disappear. It will just not work, raising an appropriate error.","title":"Dependencies"},{"location":"install/#setup-matlab","text":"Make sure that you have MATLAB and Simulink properly installed and running. CMake needs to find the Matlab installation folder in order to link the sources against its libraries. Make sure that CMake is able to find your Matlab installation , or manually set the Matlab_ROOT_DIR environment variable if needed. After this, check that the MEX compiler for MATLAB is properly configured and working. You can try compiling some of the MATLAB C code examples as described in the mex official documentation .","title":"Setup Matlab"},{"location":"install/#download-build-and-install","text":"If all the dependencies are met, proceed with the following instructions: git clone https://github.com/robotology/wb-toolbox.git mkdir -p wb-toolbox/build cd wb-toolbox/build cmake .. -DCMAKE_INSTALL_PREFIX = install-prefix cmake --build . --config Release cmake --build . --config Release --target install Note From now on, this guide refers to your install directory with the variable install-prefix . Every time you see this variable, you should substitute the absolute install path.","title":"Download, build and install"},{"location":"install/#configuration","text":"","title":"Configuration"},{"location":"install/#matlab","text":"In order to use the WB-Toolbox in Matlab you have to add some folders to the Matlab path. If you usually launch Matlab from the command line, exporting the following environment variable should be enough: export MATLABPATH = install-prefix /mex: install-prefix /share/WBToolbox: install-prefix /share/WBToolbox/images If, instead, you use the desktop launcher, a non-persistent Matlab configuration is the following: addpath ([ install-prefix / mex ]) addpath ( genpath ([ install-prefix / share / WBToolbox ])) We also provide for the latter scenario a persistent configuration of WB-Toolbox . After the installation run once the startup_wbitoolbox.m script that you can find in the install-prefix /share/WBToolbox directory. It will place a file pathdef.m in your userpath that loads the right variables to Matlab's environment. Note that this usage assumes that Matlab is always launched from the userpath folder .","title":"Matlab"},{"location":"install/#environment","text":"Each robot that can be used through WB-Toolbox has its own configuration files. WB-Toolbox uses the YARP 's ResourceFinder for finding files in the file system. You should thus follow the related instructions to properly configure your installation (e.g. setting the YARP_DATA_DIRS and YARP_ROBOT_NAME variables).","title":"Environment"},{"location":"install/#install-using-the-robotology-superbuild","text":"The robotology/robotology-superbuild provides an easy way for users to setup an environment by downloading, compiling, installing all the projects together. Follow the superbuild installation instructions and enable the ROBOTOLOGY_ENABLE_DYNAMICS profile. If WB-Toolbox is not downloaded and built, check that the ROBOTOLOGY_USES_MATLAB is ON and the ROBOTOLOGY_NOT_USE_SIMULINK is OFF . The configuration should be straightforward following the Configure your environment and Matlab sections.","title":"Install using the robotology-superbuild"},{"location":"license/","text":"LGPL v2.1 or any later version Copyright (C) 2018 Istituto Italiano di Tecnologia - iCub Facility This library is free software; you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License as published by the Free Software Foundation; either version 2.1 of the License, or (at your option) any later version. This library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details. You should have received a copy of the GNU Lesser General Public License along with this library; if not, write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA","title":"License"},{"location":"license/#lgpl-v21-or-any-later-version","text":"Copyright (C) 2018 Istituto Italiano di Tecnologia - iCub Facility This library is free software; you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License as published by the Free Software Foundation; either version 2.1 of the License, or (at your option) any later version. This library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details. You should have received a copy of the GNU Lesser General Public License along with this library; if not, write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA","title":"LGPL v2.1 or any later version"},{"location":"sim_tricks/","text":"Warning These information have not been updated for some while and might be outdated. This page contains some tricks (or not so obvious features) needed for creating Blocks in simulink Use of popup mask parameters If you need to use a popup mask parameter (i.e. a dropdown list) in you block you should notice the following thing: If EVALUATE is set to TRUE then the variable associated with the parameter will contain the INDEX (1-based) of the selection. If EVALUATE is set to FALSE then the variable associated with the parameter will contain the ACTUAL VALUE of the selection. Original source Self-modifiable blocks If you block needs to modify its options (via matlab callbacks associated with a parameter), e.g. when changing the parameters mask depending on another parameter, or when changing the number of input/outputs, be sure to check (on) the \"Mask Editor - Initialization - Allow library block to modify its contents\" Create a new block This is more heuristic than the \"correct method\", but it has been proved to work. Create a new Simulink Model and start creating the block. You can also duplicate an existing block from the Library. In this second case be sure to do the following steps: Right click on the block - Library Link - Disable Link Right click on the block - Library Link - Break Link At this point finish your work, compile the model and only at this point add the block to the library, so that its aspect will reflect the real one. Note: The step of creating the model separately is needed until we find out how to update the aspect of the block directly in the Library. Further more, this process can hinder the already existing links to the block.","title":"Simulink Tricks"},{"location":"sim_tricks/#use-of-popup-mask-parameters","text":"If you need to use a popup mask parameter (i.e. a dropdown list) in you block you should notice the following thing: If EVALUATE is set to TRUE then the variable associated with the parameter will contain the INDEX (1-based) of the selection. If EVALUATE is set to FALSE then the variable associated with the parameter will contain the ACTUAL VALUE of the selection. Original source","title":"Use of popup mask parameters"},{"location":"sim_tricks/#self-modifiable-blocks","text":"If you block needs to modify its options (via matlab callbacks associated with a parameter), e.g. when changing the parameters mask depending on another parameter, or when changing the number of input/outputs, be sure to check (on) the \"Mask Editor - Initialization - Allow library block to modify its contents\"","title":"Self-modifiable blocks"},{"location":"sim_tricks/#create-a-new-block","text":"This is more heuristic than the \"correct method\", but it has been proved to work. Create a new Simulink Model and start creating the block. You can also duplicate an existing block from the Library. In this second case be sure to do the following steps: Right click on the block - Library Link - Disable Link Right click on the block - Library Link - Break Link At this point finish your work, compile the model and only at this point add the block to the library, so that its aspect will reflect the real one.","title":"Create a new block"},{"location":"sim_tricks/#note","text":"The step of creating the model separately is needed until we find out how to update the aspect of the block directly in the Library. Further more, this process can hinder the already existing links to the block.","title":"Note:"},{"location":"troubleshooting/","text":"Problems finding libraries and libstdc++ In case Matlab has trouble finding a specific library, a workaround is to launch it preloading the variable LD_PRELOAD (or DYLD_INSERT_LIBRARIES on macOS) with the full path of the missing library. On Linux you might have trouble with libstdc++.so since Matlab comes with its own. To use your system's libstdc++ you would need to launch Matlab with: LD_PRELOAD = /usr/lib/x86_64-linux-gnu/libstdc++.so.6 matlab The current version on Ubuntu 16:04 is libstdc++.so.6 , make sure this is the case also on your OS. Tip You could additionally create an alias to launch Matlab this way: alias matlab_wbt= cd ~/Documents/MATLAB LD_PRELOAD=/usr/lib/x86_64-linux-gnu/libstdc++.so.6 matlab Info Another solution involving the .matlab7rc.sh file can be found in codyco-superbuild#141 . YARP not installed in the system default directory In case you compiled YARP in a directory different from the system default one and you are not using RPATH, you need to tell to MATLAB the location in which to find the shared libraries for YARP . If you launch MATLAB from command line, this task is already done for you by bash (if you edited .bashrc ). If you launch MATLAB from the UI (e.g. on macOS by double clicking the application icon) you need to further add the variables in ${MATLAB_ROOT}/bin/.matlab7rc.sh by first doing chmod +w .matlab7rc.sh Then looking for the variable LDPATH_SUFFIX and assign to every instance the contents of your DYLD_LIBRARY_PATH . Finally do: chmod -w .matlab7rc.sh The error message you get in this case might look something like: Library not loaded: libyarpwholeBodyinterface.0.0.1.dylib Referenced from: ${ CODYCO_SUPERBUILD_DIR } /install/mex/robotState.mexmaci64","title":"Troubleshooting"},{"location":"troubleshooting/#problems-finding-libraries-and-libstdc","text":"In case Matlab has trouble finding a specific library, a workaround is to launch it preloading the variable LD_PRELOAD (or DYLD_INSERT_LIBRARIES on macOS) with the full path of the missing library. On Linux you might have trouble with libstdc++.so since Matlab comes with its own. To use your system's libstdc++ you would need to launch Matlab with: LD_PRELOAD = /usr/lib/x86_64-linux-gnu/libstdc++.so.6 matlab The current version on Ubuntu 16:04 is libstdc++.so.6 , make sure this is the case also on your OS. Tip You could additionally create an alias to launch Matlab this way: alias matlab_wbt= cd ~/Documents/MATLAB LD_PRELOAD=/usr/lib/x86_64-linux-gnu/libstdc++.so.6 matlab Info Another solution involving the .matlab7rc.sh file can be found in codyco-superbuild#141 .","title":"Problems finding libraries and libstdc++"},{"location":"troubleshooting/#yarp-not-installed-in-the-system-default-directory","text":"In case you compiled YARP in a directory different from the system default one and you are not using RPATH, you need to tell to MATLAB the location in which to find the shared libraries for YARP . If you launch MATLAB from command line, this task is already done for you by bash (if you edited .bashrc ). If you launch MATLAB from the UI (e.g. on macOS by double clicking the application icon) you need to further add the variables in ${MATLAB_ROOT}/bin/.matlab7rc.sh by first doing chmod +w .matlab7rc.sh Then looking for the variable LDPATH_SUFFIX and assign to every instance the contents of your DYLD_LIBRARY_PATH . Finally do: chmod -w .matlab7rc.sh The error message you get in this case might look something like: Library not loaded: libyarpwholeBodyinterface.0.0.1.dylib Referenced from: ${ CODYCO_SUPERBUILD_DIR } /install/mex/robotState.mexmaci64","title":"YARP not installed in the system default directory"}]}